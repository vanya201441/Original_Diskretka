1)Декстер
Для решения алгоритма Дейкстры необходимо:
Создать класс вершины графа, содержащий своё имя (например, строку) и список рёбер, которые выходят из этой вершины.
Для каждого ребра в списке следует хранить вес.
Создать класс ребра графа, содержащий два объекта класса вершины и значение веса ребра.
Создать класс графа, содержащий список всех вершин и список всех рёбер.
Создать метод, реализующий алгоритм Дейкстры. Входными параметрами метода являются начальная вершина и конечная вершина.
Алгоритм должен проходить по всем вершинам графа и находить кратчайший путь от начальной вершины до каждой другой вершины.
В процессе работы алгоритма необходимо хранить список вершин, для которых уже найден кратчайший путь, и список вершин, для которых этот путь ещё не найден.


2)Жадный Алгоритм
Жадный алгоритм задачи коммивояжера — это алгоритм, который выбирает на каждом шаге ближайший не посещенный город, и продолжает движение до тех пор, пока все города не будут посещены.
Для решения этой задачи можно использовать алгоритм "ближайшего соседа".

3)Поиск Цикла Эйлера
Для поиска эйлерова цикла в графе необходимо использовать алгоритм Флериера:
Найти вершину с нечётной степенью, если такая есть.
Если таких вершин нет, то выбираем любую вершину.
Делаем обход в глубину, запоминая при этом все рёбра, которые мы прошли.
Когда доходим до вершины, из которой больше некуда ходить, начинаем разворачиваться назад.
При этом на каждом шаге, если мы проходим по ребру, которое мы ещё не проходили, добавляем его в ответ.
Повторяем шаги 2-4, пока не прошли по всем рёбрам.
В данном примере мы ищем эйлеров цикл в графе, заданном матрицей смежности graph.
Сначала ищем вершину с нечётной степенью, и если такой нет, то выбираем любую вершину.
Затем запускаем обход в глубину и сохраняем все рёбра, по которым мы проходим.
Когда доходим до вершины, из которой больше некуда идти, начинаем разворачиваться назад и добавляем каждое ребро в ответ, если мы проходим по нему в первый раз.


4)Поиск Гамильтонова Цикла
Решение задачи о поиске гамильтонового цикла в графе представляет собой довольно сложную задачу, которая, в общем случае, является NP-полной.
Тем не менее, для некоторых типов графов существуют эффективные алгоритмы поиска гамильтоновых циклов.
Один из наиболее распространенных алгоритмов, который основан на принципе "ответ в виде композиции", называется алгоритмом Хиршберга.
Он основан на разделении исходного графа на две части и рекурсивном поиске гамильтоновых циклов для каждой из них.
Затем полученные циклы комбинируются, чтобы образовать цикл в исходном графе.

5)Глубина
Поиск в глубину ищет как можно дальше по ветке, а затем возвращается, чтобы найти как можно дальше в следующей ветке.
Мы хотим посетить все наши узлы один раз.
Чтобы сделать это в коде, мы введем флаг visited
Теперь давайте определим Graph
Теперь добавим метод addEdge().
Мы будем использовать два метода: вспомогательный и фактический.
Во вспомогательном методе мы также проверим возможные повторяющиеся края.
Прежде чем добавить край между A и B , мы сначала удалим его, а только потом добавим.
Если кромка уже существует, это не позволяет нам добавить повторяющуюся кромку.
Если там еще не было ребра, то у нас все еще есть только одно ребро между двумя узлами.
Если край не существует, удаление несуществующего края приведет к исключению NullPointerException поэтому мы вводим временную копию списка:
Мы также добавим в наш Graph depthFirstSearch(Node node) который выполняет следующие действия:
Если node.visited == true , просто верните
Если он еще не был посещен, сделайте следующее:
Найдите первого newNode node и вызовите depthFirstSearch(newNode)
Повторите процесс для всех непосещенных соседей.

6)Ширина
Поиск в ширину (BFS) посещает "слой за слоем".
Это означает, что в Graph, как показано ниже, он сначала посещает всех дочерних элементов начального узла.
Эти дочерние элементы рассматриваются как «второй слой».
В отличие от поиска в глубину, поиск в ширину не проходит агрессивно через одну ветвь до тех пор, пока не достигнет конца, скорее,
когда мы начинаем поиск с узла, он посещает всех непосещенных соседей этого узла, прежде чем перейти ко всем непосещенным соседям другого узла
Практически также как и в глубину


















































